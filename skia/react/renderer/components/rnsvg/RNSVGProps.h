
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GeneratePropsH.js
 */
#pragma once

#include <react/renderer/components/view/ViewProps.h>
//#include <react/renderer/core/PropsParserContext.h>
#include <react/renderer/core/propsConversions.h>
#include <react/renderer/graphics/Color.h>
#include <react/renderer/imagemanager/primitives.h>
#include <vector>

namespace facebook {
namespace react {

struct RNSVGCircleFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGCircleFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGCircleFillStruct &value) {
  return "[Object RNSVGCircleFillStruct]";
}

struct RNSVGCircleStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGCircleStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGCircleStrokeStruct &value) {
  return "[Object RNSVGCircleStrokeStruct]";
}
class RNSVGCircleProps final : public ViewProps {
 public:
  RNSVGCircleProps() = default;
  RNSVGCircleProps( const RNSVGCircleProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGCircleFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGCircleStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string cx{};
  std::string cy{};
  std::string r{};
};

struct RNSVGClipPathFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGClipPathFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGClipPathFillStruct &value) {
  return "[Object RNSVGClipPathFillStruct]";
}

struct RNSVGClipPathStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGClipPathStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGClipPathStrokeStruct &value) {
  return "[Object RNSVGClipPathStrokeStruct]";
}

struct RNSVGClipPathFontStruct {
  std::string fontStyle;
  std::string fontVariant;
  std::string fontWeight;
  std::string fontStretch;
  std::string fontSize;
  std::string fontFamily;
  std::string textAnchor;
  std::string textDecoration;
  std::string letterSpacing;
  std::string wordSpacing;
  std::string kerning;
  std::string fontFeatureSettings;
  std::string fontVariantLigatures;
  std::string fontVariationSettings;
};

static inline void fromRawValue( const RawValue &value, RNSVGClipPathFontStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_fontStyle = map.find("fontStyle");
  if (tmp_fontStyle != map.end()) {
    fromRawValue( tmp_fontStyle->second, result.fontStyle);
  }
  auto tmp_fontVariant = map.find("fontVariant");
  if (tmp_fontVariant != map.end()) {
    fromRawValue( tmp_fontVariant->second, result.fontVariant);
  }
  auto tmp_fontWeight = map.find("fontWeight");
  if (tmp_fontWeight != map.end()) {
    fromRawValue( tmp_fontWeight->second, result.fontWeight);
  }
  auto tmp_fontStretch = map.find("fontStretch");
  if (tmp_fontStretch != map.end()) {
    fromRawValue( tmp_fontStretch->second, result.fontStretch);
  }
  auto tmp_fontSize = map.find("fontSize");
  if (tmp_fontSize != map.end()) {
    fromRawValue( tmp_fontSize->second, result.fontSize);
  }
  auto tmp_fontFamily = map.find("fontFamily");
  if (tmp_fontFamily != map.end()) {
    fromRawValue( tmp_fontFamily->second, result.fontFamily);
  }
  auto tmp_textAnchor = map.find("textAnchor");
  if (tmp_textAnchor != map.end()) {
    fromRawValue( tmp_textAnchor->second, result.textAnchor);
  }
  auto tmp_textDecoration = map.find("textDecoration");
  if (tmp_textDecoration != map.end()) {
    fromRawValue( tmp_textDecoration->second, result.textDecoration);
  }
  auto tmp_letterSpacing = map.find("letterSpacing");
  if (tmp_letterSpacing != map.end()) {
    fromRawValue( tmp_letterSpacing->second, result.letterSpacing);
  }
  auto tmp_wordSpacing = map.find("wordSpacing");
  if (tmp_wordSpacing != map.end()) {
    fromRawValue( tmp_wordSpacing->second, result.wordSpacing);
  }
  auto tmp_kerning = map.find("kerning");
  if (tmp_kerning != map.end()) {
    fromRawValue( tmp_kerning->second, result.kerning);
  }
  auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
  if (tmp_fontFeatureSettings != map.end()) {
    fromRawValue( tmp_fontFeatureSettings->second, result.fontFeatureSettings);
  }
  auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
  if (tmp_fontVariantLigatures != map.end()) {
    fromRawValue( tmp_fontVariantLigatures->second, result.fontVariantLigatures);
  }
  auto tmp_fontVariationSettings = map.find("fontVariationSettings");
  if (tmp_fontVariationSettings != map.end()) {
    fromRawValue( tmp_fontVariationSettings->second, result.fontVariationSettings);
  }
}

static inline std::string toString(const RNSVGClipPathFontStruct &value) {
  return "[Object RNSVGClipPathFontStruct]";
}
class RNSVGClipPathProps final : public ViewProps {
 public:
  RNSVGClipPathProps() = default;
  RNSVGClipPathProps( const RNSVGClipPathProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGClipPathFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGClipPathStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string fontSize{};
  std::string fontWeight{};
  RNSVGClipPathFontStruct font{};
};

class RNSVGDefsProps final : public ViewProps {
 public:
  RNSVGDefsProps() = default;
  RNSVGDefsProps( const RNSVGDefsProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
};

struct RNSVGEllipseFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGEllipseFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGEllipseFillStruct &value) {
  return "[Object RNSVGEllipseFillStruct]";
}

struct RNSVGEllipseStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGEllipseStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGEllipseStrokeStruct &value) {
  return "[Object RNSVGEllipseStrokeStruct]";
}
class RNSVGEllipseProps final : public ViewProps {
 public:
  RNSVGEllipseProps() = default;
  RNSVGEllipseProps( const RNSVGEllipseProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGEllipseFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGEllipseStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string cx{};
  std::string cy{};
  std::string rx{};
  std::string ry{};
};

struct RNSVGForeignObjectFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGForeignObjectFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGForeignObjectFillStruct &value) {
  return "[Object RNSVGForeignObjectFillStruct]";
}

struct RNSVGForeignObjectStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGForeignObjectStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGForeignObjectStrokeStruct &value) {
  return "[Object RNSVGForeignObjectStrokeStruct]";
}

struct RNSVGForeignObjectFontStruct {
  std::string fontStyle;
  std::string fontVariant;
  std::string fontWeight;
  std::string fontStretch;
  std::string fontSize;
  std::string fontFamily;
  std::string textAnchor;
  std::string textDecoration;
  std::string letterSpacing;
  std::string wordSpacing;
  std::string kerning;
  std::string fontFeatureSettings;
  std::string fontVariantLigatures;
  std::string fontVariationSettings;
};

static inline void fromRawValue( const RawValue &value, RNSVGForeignObjectFontStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_fontStyle = map.find("fontStyle");
  if (tmp_fontStyle != map.end()) {
    fromRawValue( tmp_fontStyle->second, result.fontStyle);
  }
  auto tmp_fontVariant = map.find("fontVariant");
  if (tmp_fontVariant != map.end()) {
    fromRawValue( tmp_fontVariant->second, result.fontVariant);
  }
  auto tmp_fontWeight = map.find("fontWeight");
  if (tmp_fontWeight != map.end()) {
    fromRawValue( tmp_fontWeight->second, result.fontWeight);
  }
  auto tmp_fontStretch = map.find("fontStretch");
  if (tmp_fontStretch != map.end()) {
    fromRawValue( tmp_fontStretch->second, result.fontStretch);
  }
  auto tmp_fontSize = map.find("fontSize");
  if (tmp_fontSize != map.end()) {
    fromRawValue( tmp_fontSize->second, result.fontSize);
  }
  auto tmp_fontFamily = map.find("fontFamily");
  if (tmp_fontFamily != map.end()) {
    fromRawValue( tmp_fontFamily->second, result.fontFamily);
  }
  auto tmp_textAnchor = map.find("textAnchor");
  if (tmp_textAnchor != map.end()) {
    fromRawValue( tmp_textAnchor->second, result.textAnchor);
  }
  auto tmp_textDecoration = map.find("textDecoration");
  if (tmp_textDecoration != map.end()) {
    fromRawValue( tmp_textDecoration->second, result.textDecoration);
  }
  auto tmp_letterSpacing = map.find("letterSpacing");
  if (tmp_letterSpacing != map.end()) {
    fromRawValue( tmp_letterSpacing->second, result.letterSpacing);
  }
  auto tmp_wordSpacing = map.find("wordSpacing");
  if (tmp_wordSpacing != map.end()) {
    fromRawValue( tmp_wordSpacing->second, result.wordSpacing);
  }
  auto tmp_kerning = map.find("kerning");
  if (tmp_kerning != map.end()) {
    fromRawValue( tmp_kerning->second, result.kerning);
  }
  auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
  if (tmp_fontFeatureSettings != map.end()) {
    fromRawValue( tmp_fontFeatureSettings->second, result.fontFeatureSettings);
  }
  auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
  if (tmp_fontVariantLigatures != map.end()) {
    fromRawValue( tmp_fontVariantLigatures->second, result.fontVariantLigatures);
  }
  auto tmp_fontVariationSettings = map.find("fontVariationSettings");
  if (tmp_fontVariationSettings != map.end()) {
    fromRawValue( tmp_fontVariationSettings->second, result.fontVariationSettings);
  }
}

static inline std::string toString(const RNSVGForeignObjectFontStruct &value) {
  return "[Object RNSVGForeignObjectFontStruct]";
}
class RNSVGForeignObjectProps final : public ViewProps {
 public:
  RNSVGForeignObjectProps() = default;
  RNSVGForeignObjectProps( const RNSVGForeignObjectProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGForeignObjectFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGForeignObjectStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string fontSize{};
  std::string fontWeight{};
  RNSVGForeignObjectFontStruct font{};
  std::string x{};
  std::string y{};
  std::string height{};
  std::string width{};
};

struct RNSVGGroupFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGGroupFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGGroupFillStruct &value) {
  return "[Object RNSVGGroupFillStruct]";
}

struct RNSVGGroupStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGGroupStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGGroupStrokeStruct &value) {
  return "[Object RNSVGGroupStrokeStruct]";
}

struct RNSVGGroupFontStruct {
  std::string fontStyle;
  std::string fontVariant;
  std::string fontWeight;
  std::string fontStretch;
  std::string fontSize;
  std::string fontFamily;
  std::string textAnchor;
  std::string textDecoration;
  std::string letterSpacing;
  std::string wordSpacing;
  std::string kerning;
  std::string fontFeatureSettings;
  std::string fontVariantLigatures;
  std::string fontVariationSettings;
};

static inline void fromRawValue( const RawValue &value, RNSVGGroupFontStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_fontStyle = map.find("fontStyle");
  if (tmp_fontStyle != map.end()) {
    fromRawValue( tmp_fontStyle->second, result.fontStyle);
  }
  auto tmp_fontVariant = map.find("fontVariant");
  if (tmp_fontVariant != map.end()) {
    fromRawValue( tmp_fontVariant->second, result.fontVariant);
  }
  auto tmp_fontWeight = map.find("fontWeight");
  if (tmp_fontWeight != map.end()) {
    fromRawValue( tmp_fontWeight->second, result.fontWeight);
  }
  auto tmp_fontStretch = map.find("fontStretch");
  if (tmp_fontStretch != map.end()) {
    fromRawValue( tmp_fontStretch->second, result.fontStretch);
  }
  auto tmp_fontSize = map.find("fontSize");
  if (tmp_fontSize != map.end()) {
    fromRawValue( tmp_fontSize->second, result.fontSize);
  }
  auto tmp_fontFamily = map.find("fontFamily");
  if (tmp_fontFamily != map.end()) {
    fromRawValue( tmp_fontFamily->second, result.fontFamily);
  }
  auto tmp_textAnchor = map.find("textAnchor");
  if (tmp_textAnchor != map.end()) {
    fromRawValue( tmp_textAnchor->second, result.textAnchor);
  }
  auto tmp_textDecoration = map.find("textDecoration");
  if (tmp_textDecoration != map.end()) {
    fromRawValue( tmp_textDecoration->second, result.textDecoration);
  }
  auto tmp_letterSpacing = map.find("letterSpacing");
  if (tmp_letterSpacing != map.end()) {
    fromRawValue( tmp_letterSpacing->second, result.letterSpacing);
  }
  auto tmp_wordSpacing = map.find("wordSpacing");
  if (tmp_wordSpacing != map.end()) {
    fromRawValue( tmp_wordSpacing->second, result.wordSpacing);
  }
  auto tmp_kerning = map.find("kerning");
  if (tmp_kerning != map.end()) {
    fromRawValue( tmp_kerning->second, result.kerning);
  }
  auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
  if (tmp_fontFeatureSettings != map.end()) {
    fromRawValue( tmp_fontFeatureSettings->second, result.fontFeatureSettings);
  }
  auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
  if (tmp_fontVariantLigatures != map.end()) {
    fromRawValue( tmp_fontVariantLigatures->second, result.fontVariantLigatures);
  }
  auto tmp_fontVariationSettings = map.find("fontVariationSettings");
  if (tmp_fontVariationSettings != map.end()) {
    fromRawValue( tmp_fontVariationSettings->second, result.fontVariationSettings);
  }
}

static inline std::string toString(const RNSVGGroupFontStruct &value) {
  return "[Object RNSVGGroupFontStruct]";
}
class RNSVGGroupProps final : public ViewProps {
 public:
  RNSVGGroupProps() = default;
  RNSVGGroupProps( const RNSVGGroupProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGGroupFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGGroupStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string fontSize{};
  std::string fontWeight{};
  RNSVGGroupFontStruct font{};
};

struct RNSVGImageFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGImageFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGImageFillStruct &value) {
  return "[Object RNSVGImageFillStruct]";
}

struct RNSVGImageStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGImageStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGImageStrokeStruct &value) {
  return "[Object RNSVGImageStrokeStruct]";
}
class RNSVGImageProps final : public ViewProps {
 public:
  RNSVGImageProps() = default;
  RNSVGImageProps( const RNSVGImageProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGImageFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGImageStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string x{};
  std::string y{};
  std::string width{};
  std::string height{};
  ImageSource src{};
  std::string align{};
  int meetOrSlice{0};
};

class RNSVGLinearGradientProps final : public ViewProps {
 public:
  RNSVGLinearGradientProps() = default;
  RNSVGLinearGradientProps( const RNSVGLinearGradientProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  std::string x1{};
  std::string y1{};
  std::string x2{};
  std::string y2{};
  std::vector<Float> gradient{};
  int gradientUnits{0};
  std::vector<Float> gradientTransform{};
};

struct RNSVGLineFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGLineFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGLineFillStruct &value) {
  return "[Object RNSVGLineFillStruct]";
}

struct RNSVGLineStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGLineStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGLineStrokeStruct &value) {
  return "[Object RNSVGLineStrokeStruct]";
}
class RNSVGLineProps final : public ViewProps {
 public:
  RNSVGLineProps() = default;
  RNSVGLineProps( const RNSVGLineProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGLineFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGLineStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string x1{};
  std::string y1{};
  std::string x2{};
  std::string y2{};
};

struct RNSVGMarkerFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGMarkerFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGMarkerFillStruct &value) {
  return "[Object RNSVGMarkerFillStruct]";
}

struct RNSVGMarkerStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGMarkerStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGMarkerStrokeStruct &value) {
  return "[Object RNSVGMarkerStrokeStruct]";
}

struct RNSVGMarkerFontStruct {
  std::string fontStyle;
  std::string fontVariant;
  std::string fontWeight;
  std::string fontStretch;
  std::string fontSize;
  std::string fontFamily;
  std::string textAnchor;
  std::string textDecoration;
  std::string letterSpacing;
  std::string wordSpacing;
  std::string kerning;
  std::string fontFeatureSettings;
  std::string fontVariantLigatures;
  std::string fontVariationSettings;
};

static inline void fromRawValue( const RawValue &value, RNSVGMarkerFontStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_fontStyle = map.find("fontStyle");
  if (tmp_fontStyle != map.end()) {
    fromRawValue( tmp_fontStyle->second, result.fontStyle);
  }
  auto tmp_fontVariant = map.find("fontVariant");
  if (tmp_fontVariant != map.end()) {
    fromRawValue( tmp_fontVariant->second, result.fontVariant);
  }
  auto tmp_fontWeight = map.find("fontWeight");
  if (tmp_fontWeight != map.end()) {
    fromRawValue( tmp_fontWeight->second, result.fontWeight);
  }
  auto tmp_fontStretch = map.find("fontStretch");
  if (tmp_fontStretch != map.end()) {
    fromRawValue( tmp_fontStretch->second, result.fontStretch);
  }
  auto tmp_fontSize = map.find("fontSize");
  if (tmp_fontSize != map.end()) {
    fromRawValue( tmp_fontSize->second, result.fontSize);
  }
  auto tmp_fontFamily = map.find("fontFamily");
  if (tmp_fontFamily != map.end()) {
    fromRawValue( tmp_fontFamily->second, result.fontFamily);
  }
  auto tmp_textAnchor = map.find("textAnchor");
  if (tmp_textAnchor != map.end()) {
    fromRawValue( tmp_textAnchor->second, result.textAnchor);
  }
  auto tmp_textDecoration = map.find("textDecoration");
  if (tmp_textDecoration != map.end()) {
    fromRawValue( tmp_textDecoration->second, result.textDecoration);
  }
  auto tmp_letterSpacing = map.find("letterSpacing");
  if (tmp_letterSpacing != map.end()) {
    fromRawValue( tmp_letterSpacing->second, result.letterSpacing);
  }
  auto tmp_wordSpacing = map.find("wordSpacing");
  if (tmp_wordSpacing != map.end()) {
    fromRawValue( tmp_wordSpacing->second, result.wordSpacing);
  }
  auto tmp_kerning = map.find("kerning");
  if (tmp_kerning != map.end()) {
    fromRawValue( tmp_kerning->second, result.kerning);
  }
  auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
  if (tmp_fontFeatureSettings != map.end()) {
    fromRawValue( tmp_fontFeatureSettings->second, result.fontFeatureSettings);
  }
  auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
  if (tmp_fontVariantLigatures != map.end()) {
    fromRawValue( tmp_fontVariantLigatures->second, result.fontVariantLigatures);
  }
  auto tmp_fontVariationSettings = map.find("fontVariationSettings");
  if (tmp_fontVariationSettings != map.end()) {
    fromRawValue( tmp_fontVariationSettings->second, result.fontVariationSettings);
  }
}

static inline std::string toString(const RNSVGMarkerFontStruct &value) {
  return "[Object RNSVGMarkerFontStruct]";
}
class RNSVGMarkerProps final : public ViewProps {
 public:
  RNSVGMarkerProps() = default;
  RNSVGMarkerProps( const RNSVGMarkerProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGMarkerFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGMarkerStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string fontSize{};
  std::string fontWeight{};
  RNSVGMarkerFontStruct font{};
  std::string refX{};
  std::string refY{};
  std::string markerHeight{};
  std::string markerWidth{};
  std::string markerUnits{};
  std::string orient{};
  Float minX{0.0};
  Float minY{0.0};
  Float vbWidth{0.0};
  Float vbHeight{0.0};
  std::string align{};
  int meetOrSlice{0};
};

struct RNSVGMaskFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGMaskFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGMaskFillStruct &value) {
  return "[Object RNSVGMaskFillStruct]";
}

struct RNSVGMaskStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGMaskStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGMaskStrokeStruct &value) {
  return "[Object RNSVGMaskStrokeStruct]";
}

struct RNSVGMaskFontStruct {
  std::string fontStyle;
  std::string fontVariant;
  std::string fontWeight;
  std::string fontStretch;
  std::string fontSize;
  std::string fontFamily;
  std::string textAnchor;
  std::string textDecoration;
  std::string letterSpacing;
  std::string wordSpacing;
  std::string kerning;
  std::string fontFeatureSettings;
  std::string fontVariantLigatures;
  std::string fontVariationSettings;
};

static inline void fromRawValue( const RawValue &value, RNSVGMaskFontStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_fontStyle = map.find("fontStyle");
  if (tmp_fontStyle != map.end()) {
    fromRawValue( tmp_fontStyle->second, result.fontStyle);
  }
  auto tmp_fontVariant = map.find("fontVariant");
  if (tmp_fontVariant != map.end()) {
    fromRawValue( tmp_fontVariant->second, result.fontVariant);
  }
  auto tmp_fontWeight = map.find("fontWeight");
  if (tmp_fontWeight != map.end()) {
    fromRawValue( tmp_fontWeight->second, result.fontWeight);
  }
  auto tmp_fontStretch = map.find("fontStretch");
  if (tmp_fontStretch != map.end()) {
    fromRawValue( tmp_fontStretch->second, result.fontStretch);
  }
  auto tmp_fontSize = map.find("fontSize");
  if (tmp_fontSize != map.end()) {
    fromRawValue( tmp_fontSize->second, result.fontSize);
  }
  auto tmp_fontFamily = map.find("fontFamily");
  if (tmp_fontFamily != map.end()) {
    fromRawValue( tmp_fontFamily->second, result.fontFamily);
  }
  auto tmp_textAnchor = map.find("textAnchor");
  if (tmp_textAnchor != map.end()) {
    fromRawValue( tmp_textAnchor->second, result.textAnchor);
  }
  auto tmp_textDecoration = map.find("textDecoration");
  if (tmp_textDecoration != map.end()) {
    fromRawValue( tmp_textDecoration->second, result.textDecoration);
  }
  auto tmp_letterSpacing = map.find("letterSpacing");
  if (tmp_letterSpacing != map.end()) {
    fromRawValue( tmp_letterSpacing->second, result.letterSpacing);
  }
  auto tmp_wordSpacing = map.find("wordSpacing");
  if (tmp_wordSpacing != map.end()) {
    fromRawValue( tmp_wordSpacing->second, result.wordSpacing);
  }
  auto tmp_kerning = map.find("kerning");
  if (tmp_kerning != map.end()) {
    fromRawValue( tmp_kerning->second, result.kerning);
  }
  auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
  if (tmp_fontFeatureSettings != map.end()) {
    fromRawValue( tmp_fontFeatureSettings->second, result.fontFeatureSettings);
  }
  auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
  if (tmp_fontVariantLigatures != map.end()) {
    fromRawValue( tmp_fontVariantLigatures->second, result.fontVariantLigatures);
  }
  auto tmp_fontVariationSettings = map.find("fontVariationSettings");
  if (tmp_fontVariationSettings != map.end()) {
    fromRawValue( tmp_fontVariationSettings->second, result.fontVariationSettings);
  }
}

static inline std::string toString(const RNSVGMaskFontStruct &value) {
  return "[Object RNSVGMaskFontStruct]";
}
class RNSVGMaskProps final : public ViewProps {
 public:
  RNSVGMaskProps() = default;
  RNSVGMaskProps( const RNSVGMaskProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGMaskFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGMaskStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string fontSize{};
  std::string fontWeight{};
  RNSVGMaskFontStruct font{};
  std::string x{};
  std::string y{};
  std::string height{};
  std::string width{};
  int maskUnits{0};
  int maskContentUnits{0};
  std::vector<Float> maskTransform{};
};

struct RNSVGPathFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGPathFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGPathFillStruct &value) {
  return "[Object RNSVGPathFillStruct]";
}

struct RNSVGPathStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGPathStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGPathStrokeStruct &value) {
  return "[Object RNSVGPathStrokeStruct]";
}
class RNSVGPathProps final : public ViewProps {
 public:
  RNSVGPathProps() = default;
  RNSVGPathProps( const RNSVGPathProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGPathFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGPathStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string d{};
};

struct RNSVGPatternFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGPatternFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGPatternFillStruct &value) {
  return "[Object RNSVGPatternFillStruct]";
}

struct RNSVGPatternStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGPatternStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGPatternStrokeStruct &value) {
  return "[Object RNSVGPatternStrokeStruct]";
}

struct RNSVGPatternFontStruct {
  std::string fontStyle;
  std::string fontVariant;
  std::string fontWeight;
  std::string fontStretch;
  std::string fontSize;
  std::string fontFamily;
  std::string textAnchor;
  std::string textDecoration;
  std::string letterSpacing;
  std::string wordSpacing;
  std::string kerning;
  std::string fontFeatureSettings;
  std::string fontVariantLigatures;
  std::string fontVariationSettings;
};

static inline void fromRawValue( const RawValue &value, RNSVGPatternFontStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_fontStyle = map.find("fontStyle");
  if (tmp_fontStyle != map.end()) {
    fromRawValue( tmp_fontStyle->second, result.fontStyle);
  }
  auto tmp_fontVariant = map.find("fontVariant");
  if (tmp_fontVariant != map.end()) {
    fromRawValue( tmp_fontVariant->second, result.fontVariant);
  }
  auto tmp_fontWeight = map.find("fontWeight");
  if (tmp_fontWeight != map.end()) {
    fromRawValue( tmp_fontWeight->second, result.fontWeight);
  }
  auto tmp_fontStretch = map.find("fontStretch");
  if (tmp_fontStretch != map.end()) {
    fromRawValue( tmp_fontStretch->second, result.fontStretch);
  }
  auto tmp_fontSize = map.find("fontSize");
  if (tmp_fontSize != map.end()) {
    fromRawValue( tmp_fontSize->second, result.fontSize);
  }
  auto tmp_fontFamily = map.find("fontFamily");
  if (tmp_fontFamily != map.end()) {
    fromRawValue( tmp_fontFamily->second, result.fontFamily);
  }
  auto tmp_textAnchor = map.find("textAnchor");
  if (tmp_textAnchor != map.end()) {
    fromRawValue( tmp_textAnchor->second, result.textAnchor);
  }
  auto tmp_textDecoration = map.find("textDecoration");
  if (tmp_textDecoration != map.end()) {
    fromRawValue( tmp_textDecoration->second, result.textDecoration);
  }
  auto tmp_letterSpacing = map.find("letterSpacing");
  if (tmp_letterSpacing != map.end()) {
    fromRawValue( tmp_letterSpacing->second, result.letterSpacing);
  }
  auto tmp_wordSpacing = map.find("wordSpacing");
  if (tmp_wordSpacing != map.end()) {
    fromRawValue( tmp_wordSpacing->second, result.wordSpacing);
  }
  auto tmp_kerning = map.find("kerning");
  if (tmp_kerning != map.end()) {
    fromRawValue( tmp_kerning->second, result.kerning);
  }
  auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
  if (tmp_fontFeatureSettings != map.end()) {
    fromRawValue( tmp_fontFeatureSettings->second, result.fontFeatureSettings);
  }
  auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
  if (tmp_fontVariantLigatures != map.end()) {
    fromRawValue( tmp_fontVariantLigatures->second, result.fontVariantLigatures);
  }
  auto tmp_fontVariationSettings = map.find("fontVariationSettings");
  if (tmp_fontVariationSettings != map.end()) {
    fromRawValue( tmp_fontVariationSettings->second, result.fontVariationSettings);
  }
}

static inline std::string toString(const RNSVGPatternFontStruct &value) {
  return "[Object RNSVGPatternFontStruct]";
}
class RNSVGPatternProps final : public ViewProps {
 public:
  RNSVGPatternProps() = default;
  RNSVGPatternProps( const RNSVGPatternProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGPatternFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGPatternStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string fontSize{};
  std::string fontWeight{};
  RNSVGPatternFontStruct font{};
  std::string x{};
  std::string y{};
  std::string height{};
  std::string width{};
  int patternUnits{0};
  int patternContentUnits{0};
  std::vector<Float> patternTransform{};
  Float minX{0.0};
  Float minY{0.0};
  Float vbWidth{0.0};
  Float vbHeight{0.0};
  std::string align{};
  int meetOrSlice{0};
};

class RNSVGRadialGradientProps final : public ViewProps {
 public:
  RNSVGRadialGradientProps() = default;
  RNSVGRadialGradientProps( const RNSVGRadialGradientProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  std::string fx{};
  std::string fy{};
  std::string cx{};
  std::string cy{};
  std::string rx{};
  std::string ry{};
  std::vector<Float> gradient{};
  int gradientUnits{0};
  std::vector<Float> gradientTransform{};
};

struct RNSVGRectFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGRectFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGRectFillStruct &value) {
  return "[Object RNSVGRectFillStruct]";
}

struct RNSVGRectStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGRectStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGRectStrokeStruct &value) {
  return "[Object RNSVGRectStrokeStruct]";
}
class RNSVGRectProps final : public ViewProps {
 public:
  RNSVGRectProps() = default;
  RNSVGRectProps( const RNSVGRectProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGRectFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGRectStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string x{};
  std::string y{};
  std::string height{};
  std::string width{};
  std::string rx{};
  std::string ry{};
};

class RNSVGSvgViewProps final : public ViewProps {
 public:
  RNSVGSvgViewProps() = default;
  RNSVGSvgViewProps( const RNSVGSvgViewProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string bbWidth{};
  std::string bbHeight{};
  Float minX{0.0};
  Float minY{0.0};
  Float vbWidth{0.0};
  Float vbHeight{0.0};
  std::string align{};
  int meetOrSlice{0};
  SharedColor tintColor{};
  std::string color{};
  std::string pointerEvents{};
};

struct RNSVGSymbolFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGSymbolFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGSymbolFillStruct &value) {
  return "[Object RNSVGSymbolFillStruct]";
}

struct RNSVGSymbolStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGSymbolStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGSymbolStrokeStruct &value) {
  return "[Object RNSVGSymbolStrokeStruct]";
}

struct RNSVGSymbolFontStruct {
  std::string fontStyle;
  std::string fontVariant;
  std::string fontWeight;
  std::string fontStretch;
  std::string fontSize;
  std::string fontFamily;
  std::string textAnchor;
  std::string textDecoration;
  std::string letterSpacing;
  std::string wordSpacing;
  std::string kerning;
  std::string fontFeatureSettings;
  std::string fontVariantLigatures;
  std::string fontVariationSettings;
};

static inline void fromRawValue( const RawValue &value, RNSVGSymbolFontStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_fontStyle = map.find("fontStyle");
  if (tmp_fontStyle != map.end()) {
    fromRawValue( tmp_fontStyle->second, result.fontStyle);
  }
  auto tmp_fontVariant = map.find("fontVariant");
  if (tmp_fontVariant != map.end()) {
    fromRawValue( tmp_fontVariant->second, result.fontVariant);
  }
  auto tmp_fontWeight = map.find("fontWeight");
  if (tmp_fontWeight != map.end()) {
    fromRawValue( tmp_fontWeight->second, result.fontWeight);
  }
  auto tmp_fontStretch = map.find("fontStretch");
  if (tmp_fontStretch != map.end()) {
    fromRawValue( tmp_fontStretch->second, result.fontStretch);
  }
  auto tmp_fontSize = map.find("fontSize");
  if (tmp_fontSize != map.end()) {
    fromRawValue( tmp_fontSize->second, result.fontSize);
  }
  auto tmp_fontFamily = map.find("fontFamily");
  if (tmp_fontFamily != map.end()) {
    fromRawValue( tmp_fontFamily->second, result.fontFamily);
  }
  auto tmp_textAnchor = map.find("textAnchor");
  if (tmp_textAnchor != map.end()) {
    fromRawValue( tmp_textAnchor->second, result.textAnchor);
  }
  auto tmp_textDecoration = map.find("textDecoration");
  if (tmp_textDecoration != map.end()) {
    fromRawValue( tmp_textDecoration->second, result.textDecoration);
  }
  auto tmp_letterSpacing = map.find("letterSpacing");
  if (tmp_letterSpacing != map.end()) {
    fromRawValue( tmp_letterSpacing->second, result.letterSpacing);
  }
  auto tmp_wordSpacing = map.find("wordSpacing");
  if (tmp_wordSpacing != map.end()) {
    fromRawValue( tmp_wordSpacing->second, result.wordSpacing);
  }
  auto tmp_kerning = map.find("kerning");
  if (tmp_kerning != map.end()) {
    fromRawValue( tmp_kerning->second, result.kerning);
  }
  auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
  if (tmp_fontFeatureSettings != map.end()) {
    fromRawValue( tmp_fontFeatureSettings->second, result.fontFeatureSettings);
  }
  auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
  if (tmp_fontVariantLigatures != map.end()) {
    fromRawValue( tmp_fontVariantLigatures->second, result.fontVariantLigatures);
  }
  auto tmp_fontVariationSettings = map.find("fontVariationSettings");
  if (tmp_fontVariationSettings != map.end()) {
    fromRawValue( tmp_fontVariationSettings->second, result.fontVariationSettings);
  }
}

static inline std::string toString(const RNSVGSymbolFontStruct &value) {
  return "[Object RNSVGSymbolFontStruct]";
}
class RNSVGSymbolProps final : public ViewProps {
 public:
  RNSVGSymbolProps() = default;
  RNSVGSymbolProps( const RNSVGSymbolProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGSymbolFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGSymbolStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string fontSize{};
  std::string fontWeight{};
  RNSVGSymbolFontStruct font{};
  Float minX{0.0};
  Float minY{0.0};
  Float vbWidth{0.0};
  Float vbHeight{0.0};
  std::string align{};
  int meetOrSlice{0};
};

struct RNSVGTextFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGTextFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGTextFillStruct &value) {
  return "[Object RNSVGTextFillStruct]";
}

struct RNSVGTextStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGTextStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGTextStrokeStruct &value) {
  return "[Object RNSVGTextStrokeStruct]";
}

struct RNSVGTextFontStruct {
  std::string fontStyle;
  std::string fontVariant;
  std::string fontWeight;
  std::string fontStretch;
  std::string fontSize;
  std::string fontFamily;
  std::string textAnchor;
  std::string textDecoration;
  std::string letterSpacing;
  std::string wordSpacing;
  std::string kerning;
  std::string fontFeatureSettings;
  std::string fontVariantLigatures;
  std::string fontVariationSettings;
};

static inline void fromRawValue( const RawValue &value, RNSVGTextFontStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_fontStyle = map.find("fontStyle");
  if (tmp_fontStyle != map.end()) {
    fromRawValue( tmp_fontStyle->second, result.fontStyle);
  }
  auto tmp_fontVariant = map.find("fontVariant");
  if (tmp_fontVariant != map.end()) {
    fromRawValue( tmp_fontVariant->second, result.fontVariant);
  }
  auto tmp_fontWeight = map.find("fontWeight");
  if (tmp_fontWeight != map.end()) {
    fromRawValue( tmp_fontWeight->second, result.fontWeight);
  }
  auto tmp_fontStretch = map.find("fontStretch");
  if (tmp_fontStretch != map.end()) {
    fromRawValue( tmp_fontStretch->second, result.fontStretch);
  }
  auto tmp_fontSize = map.find("fontSize");
  if (tmp_fontSize != map.end()) {
    fromRawValue( tmp_fontSize->second, result.fontSize);
  }
  auto tmp_fontFamily = map.find("fontFamily");
  if (tmp_fontFamily != map.end()) {
    fromRawValue( tmp_fontFamily->second, result.fontFamily);
  }
  auto tmp_textAnchor = map.find("textAnchor");
  if (tmp_textAnchor != map.end()) {
    fromRawValue( tmp_textAnchor->second, result.textAnchor);
  }
  auto tmp_textDecoration = map.find("textDecoration");
  if (tmp_textDecoration != map.end()) {
    fromRawValue( tmp_textDecoration->second, result.textDecoration);
  }
  auto tmp_letterSpacing = map.find("letterSpacing");
  if (tmp_letterSpacing != map.end()) {
    fromRawValue( tmp_letterSpacing->second, result.letterSpacing);
  }
  auto tmp_wordSpacing = map.find("wordSpacing");
  if (tmp_wordSpacing != map.end()) {
    fromRawValue( tmp_wordSpacing->second, result.wordSpacing);
  }
  auto tmp_kerning = map.find("kerning");
  if (tmp_kerning != map.end()) {
    fromRawValue( tmp_kerning->second, result.kerning);
  }
  auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
  if (tmp_fontFeatureSettings != map.end()) {
    fromRawValue( tmp_fontFeatureSettings->second, result.fontFeatureSettings);
  }
  auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
  if (tmp_fontVariantLigatures != map.end()) {
    fromRawValue( tmp_fontVariantLigatures->second, result.fontVariantLigatures);
  }
  auto tmp_fontVariationSettings = map.find("fontVariationSettings");
  if (tmp_fontVariationSettings != map.end()) {
    fromRawValue( tmp_fontVariationSettings->second, result.fontVariationSettings);
  }
}

static inline std::string toString(const RNSVGTextFontStruct &value) {
  return "[Object RNSVGTextFontStruct]";
}
class RNSVGTextProps final : public ViewProps {
 public:
  RNSVGTextProps() = default;
  RNSVGTextProps( const RNSVGTextProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGTextFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGTextStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string fontSize{};
  std::string fontWeight{};
  RNSVGTextFontStruct font{};
  std::vector<std::string> dx{};
  std::vector<std::string> dy{};
  std::vector<std::string> x{};
  std::vector<std::string> y{};
  std::vector<std::string> rotate{};
  std::string inlineSize{};
  std::string textLength{};
  std::string baselineShift{};
  std::string lengthAdjust{};
  std::string alignmentBaseline{};
  std::string verticalAlign{};
};

struct RNSVGTextPathFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGTextPathFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGTextPathFillStruct &value) {
  return "[Object RNSVGTextPathFillStruct]";
}

struct RNSVGTextPathStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGTextPathStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGTextPathStrokeStruct &value) {
  return "[Object RNSVGTextPathStrokeStruct]";
}

struct RNSVGTextPathFontStruct {
  std::string fontStyle;
  std::string fontVariant;
  std::string fontWeight;
  std::string fontStretch;
  std::string fontSize;
  std::string fontFamily;
  std::string textAnchor;
  std::string textDecoration;
  std::string letterSpacing;
  std::string wordSpacing;
  std::string kerning;
  std::string fontFeatureSettings;
  std::string fontVariantLigatures;
  std::string fontVariationSettings;
};

static inline void fromRawValue( const RawValue &value, RNSVGTextPathFontStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_fontStyle = map.find("fontStyle");
  if (tmp_fontStyle != map.end()) {
    fromRawValue( tmp_fontStyle->second, result.fontStyle);
  }
  auto tmp_fontVariant = map.find("fontVariant");
  if (tmp_fontVariant != map.end()) {
    fromRawValue( tmp_fontVariant->second, result.fontVariant);
  }
  auto tmp_fontWeight = map.find("fontWeight");
  if (tmp_fontWeight != map.end()) {
    fromRawValue( tmp_fontWeight->second, result.fontWeight);
  }
  auto tmp_fontStretch = map.find("fontStretch");
  if (tmp_fontStretch != map.end()) {
    fromRawValue( tmp_fontStretch->second, result.fontStretch);
  }
  auto tmp_fontSize = map.find("fontSize");
  if (tmp_fontSize != map.end()) {
    fromRawValue( tmp_fontSize->second, result.fontSize);
  }
  auto tmp_fontFamily = map.find("fontFamily");
  if (tmp_fontFamily != map.end()) {
    fromRawValue( tmp_fontFamily->second, result.fontFamily);
  }
  auto tmp_textAnchor = map.find("textAnchor");
  if (tmp_textAnchor != map.end()) {
    fromRawValue( tmp_textAnchor->second, result.textAnchor);
  }
  auto tmp_textDecoration = map.find("textDecoration");
  if (tmp_textDecoration != map.end()) {
    fromRawValue( tmp_textDecoration->second, result.textDecoration);
  }
  auto tmp_letterSpacing = map.find("letterSpacing");
  if (tmp_letterSpacing != map.end()) {
    fromRawValue( tmp_letterSpacing->second, result.letterSpacing);
  }
  auto tmp_wordSpacing = map.find("wordSpacing");
  if (tmp_wordSpacing != map.end()) {
    fromRawValue( tmp_wordSpacing->second, result.wordSpacing);
  }
  auto tmp_kerning = map.find("kerning");
  if (tmp_kerning != map.end()) {
    fromRawValue( tmp_kerning->second, result.kerning);
  }
  auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
  if (tmp_fontFeatureSettings != map.end()) {
    fromRawValue( tmp_fontFeatureSettings->second, result.fontFeatureSettings);
  }
  auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
  if (tmp_fontVariantLigatures != map.end()) {
    fromRawValue( tmp_fontVariantLigatures->second, result.fontVariantLigatures);
  }
  auto tmp_fontVariationSettings = map.find("fontVariationSettings");
  if (tmp_fontVariationSettings != map.end()) {
    fromRawValue( tmp_fontVariationSettings->second, result.fontVariationSettings);
  }
}

static inline std::string toString(const RNSVGTextPathFontStruct &value) {
  return "[Object RNSVGTextPathFontStruct]";
}
class RNSVGTextPathProps final : public ViewProps {
 public:
  RNSVGTextPathProps() = default;
  RNSVGTextPathProps( const RNSVGTextPathProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGTextPathFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGTextPathStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string fontSize{};
  std::string fontWeight{};
  RNSVGTextPathFontStruct font{};
  std::vector<std::string> dx{};
  std::vector<std::string> dy{};
  std::vector<std::string> x{};
  std::vector<std::string> y{};
  std::vector<std::string> rotate{};
  std::string inlineSize{};
  std::string textLength{};
  std::string baselineShift{};
  std::string lengthAdjust{};
  std::string alignmentBaseline{};
  std::string verticalAlign{};
  std::string href{};
  std::string side{};
  std::string method{};
  std::string midLine{};
  std::string spacing{};
  std::string startOffset{};
};

struct RNSVGTSpanFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGTSpanFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGTSpanFillStruct &value) {
  return "[Object RNSVGTSpanFillStruct]";
}

struct RNSVGTSpanStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGTSpanStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGTSpanStrokeStruct &value) {
  return "[Object RNSVGTSpanStrokeStruct]";
}

struct RNSVGTSpanFontStruct {
  std::string fontStyle;
  std::string fontVariant;
  std::string fontWeight;
  std::string fontStretch;
  std::string fontSize;
  std::string fontFamily;
  std::string textAnchor;
  std::string textDecoration;
  std::string letterSpacing;
  std::string wordSpacing;
  std::string kerning;
  std::string fontFeatureSettings;
  std::string fontVariantLigatures;
  std::string fontVariationSettings;
};

static inline void fromRawValue( const RawValue &value, RNSVGTSpanFontStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_fontStyle = map.find("fontStyle");
  if (tmp_fontStyle != map.end()) {
    fromRawValue( tmp_fontStyle->second, result.fontStyle);
  }
  auto tmp_fontVariant = map.find("fontVariant");
  if (tmp_fontVariant != map.end()) {
    fromRawValue( tmp_fontVariant->second, result.fontVariant);
  }
  auto tmp_fontWeight = map.find("fontWeight");
  if (tmp_fontWeight != map.end()) {
    fromRawValue( tmp_fontWeight->second, result.fontWeight);
  }
  auto tmp_fontStretch = map.find("fontStretch");
  if (tmp_fontStretch != map.end()) {
    fromRawValue( tmp_fontStretch->second, result.fontStretch);
  }
  auto tmp_fontSize = map.find("fontSize");
  if (tmp_fontSize != map.end()) {
    fromRawValue( tmp_fontSize->second, result.fontSize);
  }
  auto tmp_fontFamily = map.find("fontFamily");
  if (tmp_fontFamily != map.end()) {
    fromRawValue( tmp_fontFamily->second, result.fontFamily);
  }
  auto tmp_textAnchor = map.find("textAnchor");
  if (tmp_textAnchor != map.end()) {
    fromRawValue( tmp_textAnchor->second, result.textAnchor);
  }
  auto tmp_textDecoration = map.find("textDecoration");
  if (tmp_textDecoration != map.end()) {
    fromRawValue( tmp_textDecoration->second, result.textDecoration);
  }
  auto tmp_letterSpacing = map.find("letterSpacing");
  if (tmp_letterSpacing != map.end()) {
    fromRawValue( tmp_letterSpacing->second, result.letterSpacing);
  }
  auto tmp_wordSpacing = map.find("wordSpacing");
  if (tmp_wordSpacing != map.end()) {
    fromRawValue( tmp_wordSpacing->second, result.wordSpacing);
  }
  auto tmp_kerning = map.find("kerning");
  if (tmp_kerning != map.end()) {
    fromRawValue( tmp_kerning->second, result.kerning);
  }
  auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
  if (tmp_fontFeatureSettings != map.end()) {
    fromRawValue( tmp_fontFeatureSettings->second, result.fontFeatureSettings);
  }
  auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
  if (tmp_fontVariantLigatures != map.end()) {
    fromRawValue( tmp_fontVariantLigatures->second, result.fontVariantLigatures);
  }
  auto tmp_fontVariationSettings = map.find("fontVariationSettings");
  if (tmp_fontVariationSettings != map.end()) {
    fromRawValue( tmp_fontVariationSettings->second, result.fontVariationSettings);
  }
}

static inline std::string toString(const RNSVGTSpanFontStruct &value) {
  return "[Object RNSVGTSpanFontStruct]";
}
class RNSVGTSpanProps final : public ViewProps {
 public:
  RNSVGTSpanProps() = default;
  RNSVGTSpanProps( const RNSVGTSpanProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGTSpanFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGTSpanStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string fontSize{};
  std::string fontWeight{};
  RNSVGTSpanFontStruct font{};
  std::vector<std::string> dx{};
  std::vector<std::string> dy{};
  std::vector<std::string> x{};
  std::vector<std::string> y{};
  std::vector<std::string> rotate{};
  std::string inlineSize{};
  std::string textLength{};
  std::string baselineShift{};
  std::string lengthAdjust{};
  std::string alignmentBaseline{};
  std::string verticalAlign{};
  std::string content{};
};

struct RNSVGUseFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGUseFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGUseFillStruct &value) {
  return "[Object RNSVGUseFillStruct]";
}

struct RNSVGUseStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGUseStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGUseStrokeStruct &value) {
  return "[Object RNSVGUseStrokeStruct]";
}
class RNSVGUseProps final : public ViewProps {
 public:
  RNSVGUseProps() = default;
  RNSVGUseProps( const RNSVGUseProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGUseFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGUseStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string href{};
  std::string x{};
  std::string y{};
  std::string height{};
  std::string width{};
};

} // namespace react
} // namespace facebook
