
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GeneratePropsH.js
 */
#pragma once

#include <react/renderer/components/view/ViewProps.h>
#include <react/renderer/core/propsConversions.h>
#include <react/renderer/graphics/Color.h>
#include <react/renderer/imagemanager/primitives.h>
#include <vector>

namespace facebook {
namespace react {

struct RNSVGCircleFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGCircleFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGCircleFillStruct &value) {
  return "[Object RNSVGCircleFillStruct]";
}

struct RNSVGCircleStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGCircleStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGCircleStrokeStruct &value) {
  return "[Object RNSVGCircleStrokeStruct]";
}

class RNSVGCircleProps final : public ViewProps {
 public:
  RNSVGCircleProps() = default;
  RNSVGCircleProps( const RNSVGCircleProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGCircleFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGCircleStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string cx{};
  std::string cy{};
  std::string r{};
};


struct RNSVGGroupFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGGroupFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGGroupFillStruct &value) {
  return "[Object RNSVGGroupFillStruct]";
}

struct RNSVGGroupStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGGroupStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGGroupStrokeStruct &value) {
  return "[Object RNSVGGroupStrokeStruct]";
}

struct RNSVGGroupFontStruct {
  std::string fontStyle;
  std::string fontVariant;
  std::string fontWeight;
  std::string fontStretch;
  std::string fontSize;
  std::string fontFamily;
  std::string textAnchor;
  std::string textDecoration;
  std::string letterSpacing;
  std::string wordSpacing;
  std::string kerning;
  std::string fontFeatureSettings;
  std::string fontVariantLigatures;
  std::string fontVariationSettings;
};

static inline void fromRawValue( const RawValue &value, RNSVGGroupFontStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_fontStyle = map.find("fontStyle");
  if (tmp_fontStyle != map.end()) {
    fromRawValue( tmp_fontStyle->second, result.fontStyle);
  }
  auto tmp_fontVariant = map.find("fontVariant");
  if (tmp_fontVariant != map.end()) {
    fromRawValue( tmp_fontVariant->second, result.fontVariant);
  }
  auto tmp_fontWeight = map.find("fontWeight");
  if (tmp_fontWeight != map.end()) {
    fromRawValue( tmp_fontWeight->second, result.fontWeight);
  }
  auto tmp_fontStretch = map.find("fontStretch");
  if (tmp_fontStretch != map.end()) {
    fromRawValue( tmp_fontStretch->second, result.fontStretch);
  }
  auto tmp_fontSize = map.find("fontSize");
  if (tmp_fontSize != map.end()) {
    fromRawValue( tmp_fontSize->second, result.fontSize);
  }
  auto tmp_fontFamily = map.find("fontFamily");
  if (tmp_fontFamily != map.end()) {
    fromRawValue( tmp_fontFamily->second, result.fontFamily);
  }
  auto tmp_textAnchor = map.find("textAnchor");
  if (tmp_textAnchor != map.end()) {
    fromRawValue( tmp_textAnchor->second, result.textAnchor);
  }
  auto tmp_textDecoration = map.find("textDecoration");
  if (tmp_textDecoration != map.end()) {
    fromRawValue( tmp_textDecoration->second, result.textDecoration);
  }
  auto tmp_letterSpacing = map.find("letterSpacing");
  if (tmp_letterSpacing != map.end()) {
    fromRawValue( tmp_letterSpacing->second, result.letterSpacing);
  }
  auto tmp_wordSpacing = map.find("wordSpacing");
  if (tmp_wordSpacing != map.end()) {
    fromRawValue( tmp_wordSpacing->second, result.wordSpacing);
  }
  auto tmp_kerning = map.find("kerning");
  if (tmp_kerning != map.end()) {
    fromRawValue( tmp_kerning->second, result.kerning);
  }
  auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
  if (tmp_fontFeatureSettings != map.end()) {
    fromRawValue( tmp_fontFeatureSettings->second, result.fontFeatureSettings);
  }
  auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
  if (tmp_fontVariantLigatures != map.end()) {
    fromRawValue( tmp_fontVariantLigatures->second, result.fontVariantLigatures);
  }
  auto tmp_fontVariationSettings = map.find("fontVariationSettings");
  if (tmp_fontVariationSettings != map.end()) {
    fromRawValue( tmp_fontVariationSettings->second, result.fontVariationSettings);
  }
}

static inline std::string toString(const RNSVGGroupFontStruct &value) {
  return "[Object RNSVGGroupFontStruct]";
}
class RNSVGGroupProps final : public ViewProps {
 public:
  RNSVGGroupProps() = default;
  RNSVGGroupProps( const RNSVGGroupProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGGroupFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGGroupStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string fontSize{};
  std::string fontWeight{};
  RNSVGGroupFontStruct font{};
};

class RNSVGLinearGradientProps final : public ViewProps {
 public:
  RNSVGLinearGradientProps() = default;
  RNSVGLinearGradientProps( const RNSVGLinearGradientProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  std::string x1{};
  std::string y1{};
  std::string x2{};
  std::string y2{};
  std::vector<Float> gradient{};
  int gradientUnits{0};
  std::vector<Float> gradientTransform{};
};


struct RNSVGRectFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGRectFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGRectFillStruct &value) {
  return "[Object RNSVGRectFillStruct]";
}

struct RNSVGRectStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGRectStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGRectStrokeStruct &value) {
  return "[Object RNSVGRectStrokeStruct]";
}
class RNSVGRectProps final : public ViewProps {
 public:
  RNSVGRectProps() = default;
  RNSVGRectProps( const RNSVGRectProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGRectFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGRectStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string x{};
  std::string y{};
  std::string height{};
  std::string width{};
  std::string rx{};
  std::string ry{};
};
struct RNSVGPathFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGPathFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGPathFillStruct &value) {
  return "[Object RNSVGPathFillStruct]";
}

struct RNSVGPathStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue( const RawValue &value, RNSVGPathStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGPathStrokeStruct &value) {
  return "[Object RNSVGPathStrokeStruct]";
}
class RNSVGPathProps final : public ViewProps {
 public:
  RNSVGPathProps() = default;
  RNSVGPathProps( const RNSVGPathProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGPathFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGPathStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string d{};
};

struct RNSVGEllipseFillStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue(const RawValue &value, RNSVGEllipseFillStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGEllipseFillStruct &value) {
  return "[Object RNSVGEllipseFillStruct]";
}

struct RNSVGEllipseStrokeStruct {
  int type;
  SharedColor payload;
  std::string brushRef;
};

static inline void fromRawValue(const RawValue &value, RNSVGEllipseStrokeStruct &result) {
  auto map = (better::map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue( tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue( tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue( tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGEllipseStrokeStruct &value) {
  return "[Object RNSVGEllipseStrokeStruct]";
}
class RNSVGEllipseProps final : public ViewProps {
 public:
  RNSVGEllipseProps() = default;
  RNSVGEllipseProps(const RNSVGEllipseProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGEllipseFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGEllipseStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  std::string strokeWidth{"1"};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  std::vector<std::string> strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string cx{};
  std::string cy{};
  std::string rx{};
  std::string ry{};
};

class RNSVGSvgViewProps final : public ViewProps {
 public:
  RNSVGSvgViewProps() = default;
  RNSVGSvgViewProps( const RNSVGSvgViewProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string bbWidth{};
  std::string bbHeight{};
  Float minX{0.0};
  Float minY{0.0};
  Float vbWidth{0.0};
  Float vbHeight{0.0};
  std::string align{};
  int meetOrSlice{0};
  SharedColor tintColor{};
  SharedColor color{};
  std::string pointerEvents{};
};





} // namespace react
} // namespace facebook
